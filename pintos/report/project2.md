تمرین گروهی 2 

=====================

شماره گروه

: 3

-----

> نام و آدرس پست الکترونیکی 

> اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 

> توضیحات پیاده سازی

> نحوه تقسیم بندی تسک ها:

ابتدا تعداد issue کلی در مخزن طرشت با مشورت اعضای گروه ایجاد شد و به هر نفر تعدادی از آنها assign شد. سپس در صورت برخورد با بخش مشترکی از کد با عضو دیگر گروه یا برخورد با باگی که مربوط به بخش فرد دیگری بود جلسات متعددی برگزار شد تا به بررسی مشکلات به وجود آمده پرداخته شود. همچنین برای بهبود در روند ادغام پیاده سازی های انجام شده ابتدا جلسات یک روز در میان و سپس در جلسات روزانه به انجام این کار مشغول شدیم.

به صورت خاص هر فرد در این تمرین گروهی کار های زیر را انجام داده است:

امید رستم آبادی:

+ پیاده سازی و تغییر توابع مربوط به thread مانند thread_init، thread_create و ...
+ پیاده سازی لیست پیوندی در فایل های priority_queue
+ پیاده سازی بهینه برای به خواب بردن ریسه ها
+ تغییر در ساختار scheduler برای انتخاب بر اساس اولویت موثر ریسه های آماده اجرا

پیمان حاجی محمد:

+ پیاده سازی لیست پیوندی در فایل های priority_queue
+ پیاده سازی بهینه برای به خواب بردن ریسه ها
+ تغییر در ساختار scheduler برای انتخاب بر اساس اولویت موثر ریسه های آماده اجرا
+ پیاده سازی و تغییر توابع مربوط به قفل، سمافور و متغیر شرطی مانند sema_up, lock_release و ...

سینا مظاهری:

+ تکمیل بخش آزمایشگاه زمانبندی

علی جعفری:

+ عدم مشارکت در این فاز و فاز 1

> توضیحات پیاده سازی

در بخش مربوط به timer_sleep، پیاده سازی ای که در خود pintos انجام شده بود برای بخواب رفتن ریسه ها بدین صورت بود که ریسه مورد نظر را با کمک تابع thread_yield از حالت اجرا خارج کرده و به لیست ریسه های آماده اجرا (ready_list) اضافه می کرد و چون این فراخوانی تابع thread_yield در یک حلقه while با شرط چک کردن گذشتن از زمان خواب این ریسه قرار دارد بعد از آنکه scheduler با pop کردن های متوالی باز به ریسه در حال خواب می رسید باز آن ریسه تابع thread_yield را صدا زده و باز به درون ready_list پوش می شد و باعث ایجاد یک busy waiting می شد.
تغییری که ما در راستای رفع این مشکل انجام داده ایم این است که درون struct thread یک فیلد جدید با نام final_tick تعریف کردیم که زمان بیدار شدن ریسه را در آن نگه می داریم به کمک این فیلد جدید در تابع schedule تابع wake_up_sleeping را فراخوانی کرده که در آن چک می کنیم زمانی که tick حال حاضر از final_tick بزرگتر یا مساوی باشد (زمان بیدار شدن ریسه فرا رسیده باشد) آن ریسه را unblock کرده تا به لیست ریسه های آماده اجرا آن را اضافه کنیم. همچنین در هر بار چک کردن این موضوع در تابع wake_up_sleeping ریسه در حال خوابی را انتخاب می کنیم که کمترین مقدار final_tick را دارد (زودتر از بقیه ریسه های در حال خواب، قرار است بیدار شود) بنابراین در تابع timer_sleep بجای استفاده از یک حلقه while ابتدا final_tick را محاسبه کرده سپس ریسه جاری را به لیست ریسه های خوابیده (sleep_pq) اضافه کرده و سپس آن را block می کنیم تا دیگر به صورت خودکار توسط scheduler به حالت اجرا در نیایند.

در بخش مربوط به زمان بند اولویت دار بدین شکل عمل کردیم که در داده ساختار thread دو فیلد جدید با نام های effective_priority و base_priority تعریف کردیم. در ابتدا مقدار این دو با هم برابر بوده و مساوی priority ست شده برای ریسه اند اما در حین اجرای سیستم عامل بنا بر حالت های متفاوت ممکن است با رخداد donation مقدار effective_priority برای مدتی افزایش یابد. در scheduler به کمک این effective_priority های ریسه ها، در هر بار عملیات scheduling ریسه با اولویت بیشینه را از لیست ریسه های آماده اجرا گرفته و آن را به حالت اجرا در می آوریم، همچنین در هنگام آزاد سازی یک قفل، سمافور و یا متغیر شرطی، از بین ریسه های در صف انتظار آن قفل، سمافور و یا متغیر شرطی، ریسه با اولویت بیشینه را unblock می کنیم. 
برای پیاده سازی صحیح عملیات اهدای اولویت بدین صورت عمل کردیم که برای هر ریسه یک لیست از قفل های در دست اختیار خود نگه می داریم و هنگامی که یک قفل را در اختیار خود قرار می دهیم و ریسه ای با اولویت بالا تر درخواست دریافت آن قفل را می کند، effective_priority  خود را به صاحب آن قفل در جهت افزایش اهدا می کند تا ریسه اول هر چه زودتر به حالت اجرا درآمده و قفل در اختیار خود را آزاد کند. در هنگام آزاد کردن قفل اگر قفل یا قفل های دیگری را نیز در اختیار داشتیم، از بین آن ها effective_priority ریسه منتظر با اولویت بیشینه را پیدا کرده و از بین تمامی این effective_priority ها ماکسیمم می گیریم و در جهت افزایش اهدای اولویت بعدی را انجام می دهیم در غیر این صورت مقدار effective_priority خود را به مقدار base_priority کاهش می دهیم تا به حالت اولیه خود بر گردد. 
در تابع sema_down همچنین در صورتی که به حالت انتظار رفته  تا بتوانیم سمافور را در اختیار بگیریم، اگر خود ریسه ای که سمافور را در اختیار دارد به دلایلی block شده باشد ما آن را قبل از block کردن خودمان unblock می کنیم تا در صورت وجود امکان ریسه دوم سمافور را آزاد کرده و او نیز ما را unblock کند.
در هر جای برنامه هرگاه ریسه ای تازه به لیست ready_list اضافه می کنیم و احتمال می دهیم که اولویت موثر آن ریسه از ریسه در حال اجرا بالاتر باشد این موضوع را چک کرده در صورت صحت آن تابع thread_yield را فراخوانی کرده تا بلافاصله فرصت اجرا به ریسه با اولویت موثر بالاتر از ریسه جاری که منتظر اجراس برسد.
در تابع thread_set_priority برا جلوگیری از بروز race condition بدین صورت عمل کردیم که در ابتدای تابع interupt ها را غیر فعال کرده و سپس انجام عملیات تنظیم اولویت جدید را خواهیم داشت و در نهایت در انتهای تابع interupt ها را فعال می کنیم.

>پرسش به سوالات گزارش

+ مشکل بزرگی امنیتی از جمله نحوه مدیریت حافظه و... در پیاده سازی ما وجود ندارد زیرا تمامی allocation ها در زمان مناسب free خواهند شد و مشکلاتی من جمله memory leak نخواهیم داشت
+ کد استایل استفاده شده در تمامی بخش های کد یکسان بوده و با کد استایل pintos هم خوانی کاملی دارد
+ خیر، کد کپی شده نداریم
+ در لیست های ready_list و sleep_pq و همچنین waiters_pq از لیست پیوندی پیاده سازی شده توسط خودمان استفاده کرده ایم. توابع مربوط به این موضوع در فایلی با نام priority_queue.c/h در پوشه lib/kernel موجود می باشند
+ خیر، در صورت طولانی شدن خط کد ها ادامه آنها را به خط بعدی منتقل کرده ایم
+ خیر، در مخزن گیت هیچ پرونده باینری وجود ندارد.

