تمرین گروهی ۳ 

=====================

شماره گروه

: 3

-----

> نام و آدرس پست الکترونیکی 

> اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 

> توضیحات پیاده سازی

> نحوه تقسیم بندی تسک ها:

ابتدا تعداد issue کلی در مخزن طرشت با مشورت اعضای گروه ایجاد شد و به هر نفر تعدادی از آنها assign شد. سپس در صورت برخورد با بخش مشترکی از کد با عضو دیگر گروه یا برخورد با باگی که مربوط به بخش فرد دیگری بود جلسات متعددی برگزار شد تا به بررسی مشکلات به وجود آمده پرداخته شود. همچنین برای بهبود در روند ادغام پیاده سازی های انجام شده ابتدا جلسات یک روز در میان و سپس در جلسات روزانه به انجام این کار مشغول شدیم.

به صورت خاص هر فرد در این تمرین گروهی کار های زیر را انجام داده است:

امید رستم آبادی:

+ پیاده سازی buffer cache و نوشتن تست های مربوط
+ کمک در نوشتن فایلهای قابل گسترش


پیمان حاجی محمد:

+ کمک در نوشتن فایلهای قابل گسترش
+ کمک در توسعه مسیرها و زیرمسیرها

سینا مظاهری:

+ کمک در تکمیل توسعه مسیرها و زیرمسیرها

علی جعفری:

+ عدم مشارکت در این فاز و فاز ۱ و فاز ۲

> توضیحات پیاده سازی
بافر کش:
این بخش را مطابق سند دیزاین طراحی کردیم. تنها تغییر این است که از لیست busy_list استفاده نمیکنیم و یک فلگ is_busy و قفل busy_lock به ساختار cache_entries اضافه کرده ایم. با این کار دیگر لازم نیست هر بار لیست را پیمایش کنیم و کد نیز ساده تر میشود. همچنین الگوریتم کلاک عمومی با N شانس را پیاده کردیم که در این پیاده سازی مقدار N را برابر ۲ تنظیم کردیم.

فایلهای قابل گسترش:
این بخش نیز عیناً مانند دیزاین اولیه پیاده شده است. ۱۲۳ پوینتر مستقیم و ۱ پوینتر غیر مستقیم و ۱ پوینتر دو مرحله ای غیر مستقیم داریم. مجموعاً فضای پشتیبانی شده توسط فایل اندکی بیش از ۸ مگابایت خواسته شده است. همچنین هر ریسه در هنگام گسترش فایل یک قفل گسترش را اخذ میکند که از گسترش یک فایل توسط دو نفر به طور همزمان جلوگیری میشود.

مسیرها و زیرمسیرها:
برای این بخش نیز مطابق دیزاین عمل کرده ایم. هر بار مسیر گرفته شده را پیمایش میکنیم تا از ریشه به مسیر مورد نظر برسیم. متاسفانه به دلیل کمبود وقت و فشار کاری این بخش از ترم، امکان تکمیل این بخش به وجود نیامد.

>نحوه پیاده سازی تستهای بافرکش:
دو تست برای سنجیدن این قابلیت پیاده سازی شده است.
تست اول ابتدا یک فایل متوسط را روی دیسک ایجاد میکند و مقداری داده داخل آن مینویسد. سپس یک فایل بزرگ بی ربط را از دیسک میخواند که باعث میشود تمام بلاک های حافظه نهان اشغال شوند. سپس فایل متوسط که قبلاً ایجاد شده را میخوانیم و سپس فایل را میبندیم. بین این دو نقطه نیز با توجه به سیستم کالهای ایجاد شده تعداد درخواستهای read ارسال شده به دیسک را اندازه میگیریم. سپس پس از بستن فایل مجدداْ آن را باز کرده و میخوانیم و تعداد خواندن ها را مجدداً اندازه گیری میکنیم. از مقایسه این تعداد خواندن ها میتوانیم نتیجه بگیریم که بافرکش کار میکند یا خیر. تعداد خواندنها در حالت دوم باید تقریباً به اندازه تعداد بلاکهای فایل از حالت دوم کمتر باشد. ما این محدودیت را کمی آسانتر در نظر میگیریم که خیلی به نحوه پیاده سازی وابسته نباشد.
برای نوشتن در دیسک نیز یک فایل ۲۰۰ × ۵۱۲ بایتی را بایت به بایت در دیسک مینویسم. در آخر چک میکنیم که تعداد دسترسیها به دیسک هنگام نوشتن این فایل خیلی از ۲۰۰ بیشتر نباشد (ممکن است این بین اتفاقات دیگری هم بیفتد پس نمیشود دقیقاً ۲۰۰ را در نظر گرفت).
اگر کش وجود نداشته باشد، برای هر بایت یک درخواست نوشتن به دیسک ارسال شده که مجموعاً بیش از ۱۰۰۰۰۰ درخواست خواهد شد.

مشکلات محتمل هسته در کد hit-rate:
اگر از مکانیزم write-through استفاده شود یا تعداد خواندن ها مانند همان حالت اول میشود یا نتیجه اشتباه خواهد بود.
اگر از مکانیزم جایگزینی رندوم استفاده شود تست به احتمال بالا پاس نخواهد شد. (میتوان boundها را تنگ تر کرد).

مشکلات محتمل هسته در کد write to buffer:
اگر از مکانیزم write-through استفاده کنیم تعداد نوشتن ها فرقی با حالت معمولی نخواهد کرد.
اگر از مکانیزم جایگزینی رندوم استفاده شود تست به احتمال تقریبا ۱۰۰ درصد پاس نمیشود. چون نمیتواند ۱۰۰۰۰۰ نوشتن را به ۲۰۰ تبدیل کند.

>پرسش به سوالات گزارش

+ مشکل بزرگی امنیتی از جمله نحوه مدیریت حافظه و... در پیاده سازی ما وجود ندارد زیرا تمامی allocation ها در زمان مناسب free خواهند شد و مشکلاتی من جمله memory leak نخواهیم داشت
+ کد استایل استفاده شده در تمامی بخش های کد یکسان بوده و با کد استایل pintos هم خوانی کاملی دارد
+ خیر، کد کپی شده نداریم
+ از لیستهای pintos استفاده کرده ایم.
+ خیر، در صورت طولانی شدن خط کد ها ادامه آنها را به خط بعدی منتقل کرده ایم
+ خیر، در مخزن گیت هیچ پرونده باینری وجود ندارد.

