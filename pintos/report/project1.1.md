تمرین گروهی ۱/1 

=====================

شماره گروه
: 3

-----

> نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 



> توضیحات پیاده سازی





> نحوه تقسیم بندی تسک ها:
ابتدا تعداد issue کلی در مخزن طرشت با مشورت اعضای گروه ایجاد شد و به هر نفر تعدادی از آنها assign شد. سپس در صورت برخورد با بخش مشترکی از کد با عضو دیگر گروه یا برخورد با باگی که مربوط به بخش فرد دیگری بود جلسات متعددی برگزار شد تا به بررسی مشکلات به وجود آمده پرداخته شود. همچنین برای بهبود در روند ادغام پیاده سازی های انجام شده ابتدا جلسات یک روز در میان و سپس در جلسات روزانه به انجام این کار مشغول شدیم.
به صورت خاص هر فرد در این تمرین گروهی کار های زیر را انجام داده است:

امید رستم آبادی:

+ پیاده سازی فراخوانی های سیستمی halt, practice, seek, tell, close, open, filesize
+ پاس دادن آرگومان ها از command line
+ پیاده سازی امن فرایند خواندن و نوشتن از فضای کاربر
+ ممانعت از نوشتن در روی فایل اجرایی در حین اجرای فایل 

پیمان حاجی محمد:

+ پیاده سازی فراخوانی های سیستمی exec, wait, open, exit
+ ایجاد ساختار های child و ایجاد ارتباط آن با ریسه های پدر و ساختار open_file

سینا مظاهری:

+ پیاده سازی فراخوانی سیستمی read, write, create, remove


 
نکات مهم پیاده سازی فراخوانی های سیستمی مرتب به فایل سیستم:
همانطور که در سند تمرین نیز ذکر شده، در این تمرین نیازی به پیاده سازی این فراخوانی ها نداشتیم و فقط باید توابع مرتبط از مسیرهای مربوطه را فراخوانی می کردیم. همچنین پیاده سازی این فراخوانی های سیستمی بسیار به هم شبیه است به گونه ای که در قالب کلی زیر قابل بیان است:

1. ابتدا باید به صورت امن آرگومان های فراخوانی سیستمی را از پشته برداریم. جهت انجام این کار، از تابع is_valid_ptr(ptr, size) استفاده کردیم (در بخش های بعدی توضیح داده شده است). در صورتی که یک پردازه آرگومان ها را در فضای نامعتبری پاس دهد با کد -۱ خارج می شود. در صورتی که یکی از آرگومان های ورودی بافر باشد، باید خود بافر نیز به اندازه سایز مورد نیاز صحت سنجی شود که اطمینان حاصل کنیم کاربر به فضایی که دسترسی ندارد درخواست دسترسی نمی دهد.
2. پس از این که صحت همه موارد بررسی شد، باید کار اصلی را انجام دهیم. که کافی است ابتدا قفل عمومی مربوط به فایل سیستم را قفل کرده و سپس تابع فایل سیستم مربوطه را صدا بزنیم و در نهایت قفل را آزاد می کنیم. همچنین مقدار برگشتی فایل سیستم (در صورت وجود) را نیز در رجیستر eax قرار می دهیم که به کاربر برگردانده شود.

پاس دادن آرگومان های خط فرمان به برنامه:
در این پروژه ما فرض می کنیم که همه آرگومان ها در یک صفحه حافظه جا می شوند. بدین منظور ابتدا صفحه ای را در بالاترین قسمت حافظه مجازی گرفته و اشاره گر پشته را به بالای آن تنظیم می کنیم. سپس ابتدا رشته ها را در صفحه کپی کرده و به تدریج اشاره گر را پایین می آوریم. سپس آدرس هر کدام از رشته ها را به ترتیب در پشته قرار داده و به گونه ای تنظیم می کنیم که اشاره گر پشته قبل از فراخوانی call دقیقا در عددی مضرب ۱۶ بایت قرار بگیرد (calling convention). 

پیاده سازی امنیت خواندن و نوشتن داده ها در فضای کاربر:
برای این مورد مطابق مورد عنوان شده در طراحی، یک تابع is_valid_ptr طراحی کردیم که یک اشاره گر به فضای کاربر را می گیرد و به تعداد size بایت از آن را چک می کند که توسط پردازه کاربر قابل دسترسی باشد. کافی است شرط های گفته شده در بخش ۴.۲.۴ سند مرجع pintos را چک کنیم. اما یک نکته که در طراحی مد نظر قرار نداده بودیم، وجود رشته هاست. بعضی از فراخوانی های سیستمی رشته را به عنوان ورودی خود دریافت می کنند. طول رشته ها در زبان C از قبل مشخص نیست. لذا نمی توان از تابع is_valid_ptr استفاده کرد. برای حل این مورد تابع دیگری به نام is_valid_str نوشتیم که قابلیت این را دارد که روی یک رشته حرکت کند و از اول تا آخر (رسیدن به بایت '\0') را صحت سنجی کند. این تابع بر خلاف is_valid_ptr تنها ورودی اشاره گر را دریافت می کند و نیازی به دانستن size نیست.

ممانعت از نوشتن روی فایل اجرای پردازه ها:
برای این کار نیاز شد که یک عضو جدید به ساختار ریسه ها اضافه کنیم که یک اشاره گر به فایل اجرایی آن پردازه است. پس از بارگذاری موفق فایل در ابتدای برنامه، تابع file_deny_write روی این فایل صدا زده می شود که نوشتن در آن را منع کند و سپس در تابع thread_exit هنگام خروج پردازه این فایل را می بندیم. با بستن فایل عملا allow_write هم اتفاق می افتد.

