تمرین گروهی ۱/1 

=====================

شماره گروه

: 3

-----

> نام و آدرس پست الکترونیکی 
> اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 

> توضیحات پیاده سازی

> نحوه تقسیم بندی تسک ها:

ابتدا تعداد issue کلی در مخزن طرشت با مشورت اعضای گروه ایجاد شد و به هر نفر تعدادی از آنها assign شد. سپس در صورت برخورد با بخش مشترکی از کد با عضو دیگر گروه یا برخورد با باگی که مربوط به بخش فرد دیگری بود جلسات متعددی برگزار شد تا به بررسی مشکلات به وجود آمده پرداخته شود. همچنین برای بهبود در روند ادغام پیاده سازی های انجام شده ابتدا جلسات یک روز در میان و سپس در جلسات روزانه به انجام این کار مشغول شدیم.

به صورت خاص هر فرد در این تمرین گروهی کار های زیر را انجام داده است:

امید رستم آبادی:

+ پیاده سازی فراخوانی های سیستمی halt, practice, seek, tell, close, open, filesize

+ پاس دادن آرگومان ها از command line

+ پیاده سازی امن فرایند خواندن و نوشتن از فضای کاربر

+ ممانعت از نوشتن در روی فایل اجرایی در حین اجرای فایل 

پیمان حاجی محمد:

+ پیاده سازی فراخوانی های سیستمی exec, wait, open, exit

+ ایجاد ساختار های child و ایجاد ارتباط آن با ریسه های پدر و ساختار open_file

سینا مظاهری:

+ پیاده سازی فراخوانی سیستمی read, write, create, remove

1. تابع create به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع دو آرگومان می گیرد که یکی اسم فایل سیستمی است که باید ایجاد شود و دیگری اندازه اولیه آن می باشد. این تابع از  filesys_create استفاده می کند. این تابع نتیجه انجام عملیات را در ثبات eax به شکل یک بولین ذخیره می کند.

2. تابع remove به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع یک آرگومان می گیرد که  اسم فایل سیستمی است که باید حذف شود. این تابع از  filesys_remove استفاده می کند. این تابع

   نتیجه انجام عملیات را در ثبات eax به شکل یک بولین ذخیره می کند.

3. تابع write به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع سه آرگومان می گیرد که یکی توصیف کننده فایل از لیست توصیف کننده های فایل های باز کاربر می باشد. دیگری نیز اشاره گری به بافر کاربر است و در نهایت هم اندازه مقدار بایتی که باید نوشته شود دریافت می شود نوع توصیف کننده فایل بررسی می شود و متناسب با آن و در حالتی که ورودی/خروجی استاندارد نباشد با استفاده از تابع get_open_file_by_fd()  ، ساختار فایل یا همان struct file مورد نظر برگردانده می شود و با استفاده از file_write در آن نوشته می شود. این تابع تعداد بایت های نوشته شده واقعی را به عنوان نتیجه انجام عملیات در ثبات eax به ذخیره می کند.

4. تابع read به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع سه آرگومان می گیرد که یکی توصیف کننده فایل از لیست توصیف کننده های فایل های باز کاربر می باشد. دیگری نیز اشاره گری به بافر کاربر است و در نهایت هم اندازه مقدار بایتی که باید خوانده شود دریافت می شود نوع توصیف کننده فایل بررسی می شود و متناسب با آن و در حالتی که ورودی/خروجی استاندارد نباشد با استفاده از تابع get_open_file_by_fd()  ، ساختار فایل یا همان struct file مورد نظر برگردانده می شود و با استفاده از file_read در آن نوشته می شود. این تابع تعداد بایت های خوانده شده واقعی را به عنوان نتیجه انجام عملیات در ثبات eax به ذخیره می کند.

این توابع نسبت به سند اولیه تغییر چندانی نداشته اند و در بخش حافظه Memory Leak نیز ندارند از یک کد استایل مشابه به بقیه اعضای گروه استفاده شده است. اما مشابه pintos ممکن است نباشد. کد ساده و قابل درک است و این توابع کامنت ندارند از هیچ داده ساختاری در آن استفاده نشده است و طول خط های آن کم است و فایل های باینری نیز آپلود نشده است. لازم به ذکر است که با استفاده از منابع مفاهیم کد استخراج شده و متناسب با معماری پروژه پیاده سازی شده است.

نکات مهم پیاده سازی فراخوانی های سیستمی مرتب به فایل سیستم:

همانطور که در سند تمرین نیز ذکر شده، در این تمرین نیازی به پیاده سازی این فراخوانی ها نداشتیم و فقط باید توابع مرتبط از مسیرهای مربوطه را فراخوانی می کردیم. همچنین پیاده سازی این فراخوانی های سیستمی بسیار به هم شبیه است به گونه ای که در قالب کلی زیر قابل بیان است:

1. ابتدا باید به صورت امن آرگومان های فراخوانی سیستمی را از پشته برداریم. جهت انجام این کار، از تابع is_valid_ptr(ptr, size) استفاده کردیم (در بخش های بعدی توضیح داده شده است). در صورتی که یک پردازه آرگومان ها را در فضای نامعتبری پاس دهد با کد -۱ خارج می شود. در صورتی که یکی از آرگومان های ورودی بافر باشد، باید خود بافر نیز به اندازه سایز مورد نیاز صحت سنجی شود که اطمینان حاصل کنیم کاربر به فضایی که دسترسی ندارد درخواست دسترسی نمی دهد.

2. پس از این که صحت همه موارد بررسی شد، باید کار اصلی را انجام دهیم. که کافی است ابتدا قفل عمومی مربوط به فایل سیستم را قفل کرده و سپس تابع فایل سیستم مربوطه را صدا بزنیم و در نهایت قفل را آزاد می کنیم. همچنین مقدار برگشتی فایل سیستم (در صورت وجود) را نیز در رجیستر eax قرار می دهیم که به کاربر برگردانده شود.

پاس دادن آرگومان های خط فرمان به برنامه:

در این پروژه ما فرض می کنیم که همه آرگومان ها در یک صفحه حافظه جا می شوند. بدین منظور ابتدا صفحه ای را در بالاترین قسمت حافظه مجازی گرفته و اشاره گر پشته را به بالای آن تنظیم می کنیم. سپس ابتدا رشته ها را در صفحه کپی کرده و به تدریج اشاره گر را پایین می آوریم. سپس آدرس هر کدام از رشته ها را به ترتیب در پشته قرار داده و به گونه ای تنظیم می کنیم که اشاره گر پشته قبل از فراخوانی call دقیقا در عددی مضرب ۱۶ بایت قرار بگیرد (calling convention). 

پیاده سازی امنیت خواندن و نوشتن داده ها در فضای کاربر:

برای این مورد مطابق مورد عنوان شده در طراحی، یک تابع is_valid_ptr طراحی کردیم که یک اشاره گر به فضای کاربر را می گیرد و به تعداد size بایت از آن را چک می کند که توسط پردازه کاربر قابل دسترسی باشد. کافی است شرط های گفته شده در بخش ۴.۲.۴ سند مرجع pintos را چک کنیم. اما یک نکته که در طراحی مد نظر قرار نداده بودیم، وجود رشته هاست. بعضی از فراخوانی های سیستمی رشته را به عنوان ورودی خود دریافت می کنند. طول رشته ها در زبان C از قبل مشخص نیست. لذا نمی توان از تابع is_valid_ptr استفاده کرد. برای حل این مورد تابع دیگری به نام is_valid_str نوشتیم که قابلیت این را دارد که روی یک رشته حرکت کند و از اول تا آخر (رسیدن به بایت '\0') را صحت سنجی کند. این تابع بر خلاف is_valid_ptr تنها ورودی اشاره گر را دریافت می کند و نیازی به دانستن size نیست.

ممانعت از نوشتن روی فایل اجرای پردازه ها:

برای این کار نیاز شد که یک عضو جدید به ساختار ریسه ها اضافه کنیم که یک اشاره گر به فایل اجرایی آن پردازه است. پس از بارگذاری موفق فایل در ابتدای برنامه، تابع file_deny_write روی این فایل صدا زده می شود که نوشتن در آن را منع کند و سپس در تابع thread_exit هنگام خروج پردازه این فایل را می بندیم. با بستن فایل عملا allow_write هم اتفاق می افتد.

پیاده سازی فراخوانی سیستمی exec

برای پیاده سازی این بخش ابتدا نیاز بود تا به کمک linked list پیاده سازی شده از قبل و همچنین طبق صحبت های انجام شده با دستیاران آموزشی یک ساختار child تعریف کرده و به ازای هر ریسه ساختار child معادل با آن را در اشاره گر its_child ذخیره می کنیم، سپس لیست ساختار های child فرزندان هر ریسه را نیز در لیست children هر ریسه نگه می داریم. این ساختار child دارای فیلد هایی نظیر کد خروج، وضعیت بارگذاری، سمافور های مربوط به wait و load و همچنین وضعیت پدر دار بودن یا نبودن آن و tid مربوط به ریسه معادل است. 
تغییرات اعمال شده در تابع process_execute مرتبط با پاس دادن آرگومان ها و ایجاد و اختصاص حافظه به ساختار child ریسه جدید بوده که پس از ایجاد آدرس آن درون اشاره گر its_child ریسه جدید قرار میگیرد. در قسمت exec_handler پس از فراخوانی process_exec توسط ریسه پدر و دریافت tid ریسه فرزند، در بین فرزندان خود به دنبال فرزند با tid داده شده می گردد و سپس سمافور load آن را down کرده و منتظر بارگذاری موفق فایل اجرایی ریسه فرزند باقی می ماند. در ریسه فرزند در تابع start_process پس از اجرای تابع load خروجی تابع بررسی می شود که در صورت ناموفق بودن آن سمافور ذکر شده up شده و خروجی تابع process_execute منفی یک تنظیم می شود و همچنین ریسه فرزند به اجرای خود خاتمه می دهد. 

پیاده سازی فراخوانی سیستمی wait

پس از فراخوانی wait_handler توسط syscall_handler تابع process_wait فراخوانی می شود، تغییر اعمال شده در این تابع متناسب با پیاده سازی نوع ساختار child بوده و سمافور های قبلی temporary که برای منتظر نگه داشتن ریسه پدر برای اتمام اجرای ریسه فرزند بود جایگزین سمافور wait درون ساختار child شده اند. در این تابع با کمک ورودی child_tid بررسی می شود که آیا tid مربوطه مال یکی از فرزندان ریسه جاری می باشد یا خیر، در صورت معتبر نبودن tid کد خروجی -1 برگردانده می شود. حال اگر ساختار فرزند معادل با child_tid را پیدا کردیم سمافور wait آن را down کرده و منتظر خروج کامل ریسه فرزند می مانیم. سپس exit code ثبت شده در ساختار child فرزند را در خروجی فرستاده و همچنین ساختار child فرزند خارج شد را از لیست فرزندان ریسه جاری حذف و همچنین free می کنیم.
در توابع process_exit و thread_exit نیز تغییراتی مبنی بر آزاد سازی حافظه های اختصاص داده شده و نیز up کردن سمافور wait برای رفع عدم انتظار ریسه پدر ایجاد شده اند.

پیاده سازی تابع exit_process

این تابع بگونه ای طراحی شده است که در صورت عدم موفقیت عملیاتی در هر کجای کد با فراخوانی آن با کد خروج مناسب، ریسه جاری را آزاد و حذف کند و کد خروجی ورودی را نیز جاپ کند.



