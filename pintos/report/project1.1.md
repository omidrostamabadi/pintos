تمرین گروهی ۱/1 

=====================

شماره گروه
: 3

-----

> نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 



> توضیحات پیاده سازی





> نحوه تقسیم بندی تسک ها:
ابتدا تعداد issue کلی در مخزن طرشت با مشورت اعضای گروه ایجاد شد و به هر نفر تعدادی از آنها assign شد. سپس در صورت برخورد با بخش مشترکی از کد با عضو دیگر گروه یا برخورد با باگی که مربوط به بخش فرد دیگری بود جلسات متعددی برگزار شد تا به بررسی مشکلات به وجود آمده پرداخته شود. همچنین برای بهبود در روند ادغام پیاده سازی های انجام شده ابتدا جلسات یک روز در میان و سپس در جلسات روزانه به انجام این کار مشغول شدیم.
به صورت خاص هر فرد در این تمرین گروهی کار های زیر را انجام داده است:

امید رستم آبادی:

+ پیاده سازی فراخوانی های سیستمی halt, practice, seek, tell, close, open, filesize
+ پاس دادن آرگومان ها از command line
+ پیاده سازی امن فرایند خواندن و نوشتن از فضای کاربر
+ ممانعت از نوشتن در روی فایل اجرایی در حین اجرای فایل 

پیمان حاجی محمد:

+ پیاده سازی فراخوانی های سیستمی exec, wait, open, exit
+ ایجاد ساختار های child و ایجاد ارتباط آن با ریسه های پدر و ساختار open_file

سینا مظاهری:

+ پیاده سازی فراخوانی سیستمی read, write, create, remove

1. تابع create به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع دو آرگومان می گیرد که یکی اسم فایل سیستمی است که باید ایجاد شود و دیگری اندازه اولیه آن می باشد. این تابع از  filesys_create استفاده می کند. این تابع نتیجه انجام عملیات را در ثبات eax به شکل یک بولین ذخیره می کند.


2. تابع remove به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع یک آرگومان می گیرد که  اسم فایل سیستمی است که باید حذف شود. این تابع از  filesys_remove استفاده می کند. این تابع
   نتیجه انجام عملیات را در ثبات eax به شکل یک بولین ذخیره می کند.


3. تابع write به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع سه آرگومان می گیرد که یکی توصیف کننده فایل از لیست توصیف کننده های فایل های باز کاربر می باشد. دیگری نیز اشاره گری به بافر کاربر است و در نهایت هم اندازه مقدار بایتی که باید نوشته شود دریافت می شود نوع توصیف کننده فایل بررسی می شود و متناسب با آن و در حالتی که ورودی/خروجی استاندارد نباشد با استفاده از تابع get_open_file_by_fd()  ، ساختار فایل یا همان struct file مورد نظر برگردانده می شود و با استفاده از file_write در آن نوشته می شود. این تابع تعداد بایت های نوشته شده واقعی را به عنوان نتیجه انجام عملیات در ثبات eax به ذخیره می کند.



4. تابع read به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع سه آرگومان می گیرد که یکی توصیف کننده فایل از لیست توصیف کننده های فایل های باز کاربر می باشد. دیگری نیز اشاره گری به بافر کاربر است و در نهایت هم اندازه مقدار بایتی که باید خوانده شود دریافت می شود نوع توصیف کننده فایل بررسی می شود و متناسب با آن و در حالتی که ورودی/خروجی استاندارد نباشد با استفاده از تابع get_open_file_by_fd()  ، ساختار فایل یا همان struct file مورد نظر برگردانده می شود و با استفاده از file_read در آن نوشته می شود. این تابع تعداد بایت های خوانده شده واقعی را به عنوان نتیجه انجام عملیات در ثبات eax به ذخیره می کند.

این توابع نسبت به سند اولیه تغییر چندانی نداشته اند و در بخش حافظه Memory Leak نیز ندارند از یک کد استایل مشابه به بقیه اعضای گروه استفاده شده است. اما مشابه pintos ممکن است نباشد. کد ساده و قابل درک است و این توابع کامنت ندارند از هیچ داده ساختاری در آن استفاده نشده است و طول خط های آن کم است و فایل های باینری نیز آپلود نشده است. لازم به ذکر است که با استفاده از منابع مفاهیم کد استخراج شده و متناسب با معماری پروژه پیاده سازی شده است.

 


