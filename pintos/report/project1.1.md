تمرین گروهی ۱/1 

=====================

شماره گروه
: 3

-----

> نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 



> توضیحات پیاده سازی





> نحوه تقسیم بندی تسک ها:
ابتدا تعداد issue کلی در مخزن طرشت با مشورت اعضای گروه ایجاد شد و به هر نفر تعدادی از آنها assign شد. سپس در صورت برخورد با بخش مشترکی از کد با عضو دیگر گروه یا برخورد با باگی که مربوط به بخش فرد دیگری بود جلسات متعددی برگزار شد تا به بررسی مشکلات به وجود آمده پرداخته شود. همچنین برای بهبود در روند ادغام پیاده سازی های انجام شده ابتدا جلسات یک روز در میان و سپس در جلسات روزانه به انجام این کار مشغول شدیم.
به صورت خاص هر فرد در این تمرین گروهی کار های زیر را انجام داده است:

امید رستم آبادی:

+ پیاده سازی فراخوانی های سیستمی halt, practice, seek, tell, close, open, filesize
+ پاس دادن آرگومان ها از command line
+ پیاده سازی امن فرایند خواندن و نوشتن از فضای کاربر
+ ممانعت از نوشتن در روی فایل اجرایی در حین اجرای فایل 

پیمان حاجی محمد:

+ پیاده سازی فراخوانی های سیستمی exec, wait, open, exit
+ ایجاد ساختار های child و ایجاد ارتباط آن با ریسه های پدر و ساختار open_file

سینا مظاهری:

+ پیاده سازی فراخوانی سیستمی read, write, create, remove

1. تابع create به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع دو آرگومان می گیرد که یکی اسم فایل سیستمی است که باید ایجاد شود و دیگری اندازه اولیه آن می باشد. این تابع از  filesys_create استفاده می کند. این تابع نتیجه انجام عملیات را در ثبات eax به شکل یک بولین ذخیره می کند.


2. تابع remove به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع یک آرگومان می گیرد که  اسم فایل سیستمی است که باید حذف شود. این تابع از  filesys_remove استفاده می کند. این تابع
   نتیجه انجام عملیات را در ثبات eax به شکل یک بولین ذخیره می کند.


3. تابع write به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع سه آرگومان می گیرد که یکی توصیف کننده فایل از لیست توصیف کننده های فایل های باز کاربر می باشد. دیگری نیز اشاره گری به بافر کاربر است و در نهایت هم اندازه مقدار بایتی که باید نوشته شود دریافت می شود نوع توصیف کننده فایل بررسی می شود و متناسب با آن و در حالتی که ورودی/خروجی استاندارد نباشد با استفاده از تابع get_open_file_by_fd()  ، ساختار فایل یا همان struct file مورد نظر برگردانده می شود و با استفاده از file_write در آن نوشته می شود. این تابع تعداد بایت های نوشته شده واقعی را به عنوان نتیجه انجام عملیات در ثبات eax به ذخیره می کند.



4. تابع read به شکل thread_safe و با استفاده از یک سمافور که ناحیه بحرانی را برای ما امن می سازد پیاده سازی شده است. این تابع سه آرگومان می گیرد که یکی توصیف کننده فایل از لیست توصیف کننده های فایل های باز کاربر می باشد. دیگری نیز اشاره گری به بافر کاربر است و در نهایت هم اندازه مقدار بایتی که باید خوانده شود دریافت می شود نوع توصیف کننده فایل بررسی می شود و متناسب با آن و در حالتی که ورودی/خروجی استاندارد نباشد با استفاده از تابع get_open_file_by_fd()  ، ساختار فایل یا همان struct file مورد نظر برگردانده می شود و با استفاده از file_read در آن نوشته می شود. این تابع تعداد بایت های خوانده شده واقعی را به عنوان نتیجه انجام عملیات در ثبات eax به ذخیره می کند.

این توابع نسبت به سند اولیه تغییر چندانی نداشته اند و در بخش حافظه Memory Leak نیز ندارند از یک کد استایل مشابه به بقیه اعضای گروه استفاده شده است. اما مشابه pintos ممکن است نباشد. کد ساده و قابل درک است و این توابع کامنت ندارند از هیچ داده ساختاری در آن استفاده نشده است و طول خط های آن کم است و فایل های باینری نیز آپلود نشده است. لازم به ذکر است که با استفاده از منابع مفاهیم کد استخراج شده و متناسب با معماری پروژه پیاده سازی شده است.

 
نکات مهم پیاده سازی فراخوانی های سیستمی مرتب به فایل سیستم:
همانطور که در سند تمرین نیز ذکر شده، در این تمرین نیازی به پیاده سازی این فراخوانی ها نداشتیم و فقط باید توابع مرتبط از مسیرهای مربوطه را فراخوانی می کردیم. همچنین پیاده سازی این فراخوانی های سیستمی بسیار به هم شبیه است به گونه ای که در قالب کلی زیر قابل بیان است:

1. ابتدا باید به صورت امن آرگومان های فراخوانی سیستمی را از پشته برداریم. جهت انجام این کار، از تابع is_valid_ptr(ptr, size) استفاده کردیم (در بخش های بعدی توضیح داده شده است). در صورتی که یک پردازه آرگومان ها را در فضای نامعتبری پاس دهد با کد -۱ خارج می شود. در صورتی که یکی از آرگومان های ورودی بافر باشد، باید خود بافر نیز به اندازه سایز مورد نیاز صحت سنجی شود که اطمینان حاصل کنیم کاربر به فضایی که دسترسی ندارد درخواست دسترسی نمی دهد.
2. پس از این که صحت همه موارد بررسی شد، باید کار اصلی را انجام دهیم. که کافی است ابتدا قفل عمومی مربوط به فایل سیستم را قفل کرده و سپس تابع فایل سیستم مربوطه را صدا بزنیم و در نهایت قفل را آزاد می کنیم. همچنین مقدار برگشتی فایل سیستم (در صورت وجود) را نیز در رجیستر eax قرار می دهیم که به کاربر برگردانده شود.

پاس دادن آرگومان های خط فرمان به برنامه:
در این پروژه ما فرض می کنیم که همه آرگومان ها در یک صفحه حافظه جا می شوند. بدین منظور ابتدا صفحه ای را در بالاترین قسمت حافظه مجازی گرفته و اشاره گر پشته را به بالای آن تنظیم می کنیم. سپس ابتدا رشته ها را در صفحه کپی کرده و به تدریج اشاره گر را پایین می آوریم. سپس آدرس هر کدام از رشته ها را به ترتیب در پشته قرار داده و به گونه ای تنظیم می کنیم که اشاره گر پشته قبل از فراخوانی call دقیقا در عددی مضرب ۱۶ بایت قرار بگیرد (calling convention). 

پیاده سازی امنیت خواندن و نوشتن داده ها در فضای کاربر:
برای این مورد مطابق مورد عنوان شده در طراحی، یک تابع is_valid_ptr طراحی کردیم که یک اشاره گر به فضای کاربر را می گیرد و به تعداد size بایت از آن را چک می کند که توسط پردازه کاربر قابل دسترسی باشد. کافی است شرط های گفته شده در بخش ۴.۲.۴ سند مرجع pintos را چک کنیم. اما یک نکته که در طراحی مد نظر قرار نداده بودیم، وجود رشته هاست. بعضی از فراخوانی های سیستمی رشته را به عنوان ورودی خود دریافت می کنند. طول رشته ها در زبان C از قبل مشخص نیست. لذا نمی توان از تابع is_valid_ptr استفاده کرد. برای حل این مورد تابع دیگری به نام is_valid_str نوشتیم که قابلیت این را دارد که روی یک رشته حرکت کند و از اول تا آخر (رسیدن به بایت '\0') را صحت سنجی کند. این تابع بر خلاف is_valid_ptr تنها ورودی اشاره گر را دریافت می کند و نیازی به دانستن size نیست.

ممانعت از نوشتن روی فایل اجرای پردازه ها:
برای این کار نیاز شد که یک عضو جدید به ساختار ریسه ها اضافه کنیم که یک اشاره گر به فایل اجرایی آن پردازه است. پس از بارگذاری موفق فایل در ابتدای برنامه، تابع file_deny_write روی این فایل صدا زده می شود که نوشتن در آن را منع کند و سپس در تابع thread_exit هنگام خروج پردازه این فایل را می بندیم. با بستن فایل عملا allow_write هم اتفاق می افتد.

