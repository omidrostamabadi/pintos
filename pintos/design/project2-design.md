
 
 سیستم‌های عامل - تمرین گروهی دوم

## مشخصات گروه

>> نام، نام خانوادگی و ایمیل خود را در ادامه وارد کنید.

علی جعفری [alijafari13791397@gmail.com]

امید رستم آبادی [omidrostamabadi@gmail.com]

سینا مظاهری [sinamazaheri1707@gmail.com]

پیمان حاجی محمد [peyman.eb15@gmail.com]

## مقدمه

>> اگر نکته‌ای درباره فایل‌های سابمیت شده یا برای TAها دارید، لطفا اینجا بیان کنید.

>> اگر از هر منبع برخط یا غیر برخطی به غیر از مستندات Pintos، متن درس، اسلایدهای درس یا نکات گفته شده در کلاس در تمرین گروهی استفاده کرده‌اید، لطفا اینجا آن(ها) را ذکر کنید.

## ساعت زنگ‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در 25 کلمه یا کمتر توضیح بنویسید.

    struct sleep_thread{

        struct thread* the_thread;

        int64_t final_tick;

        struct sleep_thread* left_child;

        struct sleep_thread* right_child;

    }

    struct sleep_thread* sleep_pq;

### الگوریتم

>> پرسش دوم: به اختصار آن‌چه هنگام صدا زدن تابع `timer_sleep()` رخ می‌دهد و همچنین اثر `timer interrupt handler` را توضیح دهید.

>در ابتدای تابع با فراخوانی تابع timer_sleep تعداد tick های  اولیه را در یک متغیر به نام start  ذخیره می کنیم سپس بررسی میکنیم که وقفه ها خاموش شده باشند.سپس تا زمانی که ticks تا زمان نگذشته باشد تابع thread_yield() را فراخوانی می کنیم که در آن تابع وضعیت ریسه جاری را به THREAD_READY تغییر داده و به انتهای صف ready_list اضافه می کنیم و scheduler را صدا می زنیم تا ریسه بعدی را از ابتدای این صف اجرا کند. زمانی که scheduler این ریسه در حال خواب را اجرا کرد دوباره شرط گذشت زمان (timer_elapsed(start)< ticks) مدنظر را دوباره بررسی کرده و در صورت درست بودن روند بالا تکرار می شود و درغیر اینصورت از این تابع خارج می شویم. (ریسه ازحالت توقف بیرون می آید ) 

در timer interrupt handler هر بار متغیر ticks یک واحد زیاد می شود و پس از آن با صدا زدن تابع thread_tick() بسته به اینکه thread فعلی از نوع user ، kernel یا idle باشد tick های مربوطه یکی زیاد می شود و در نهایت اگر tick های thread فعلی بیشتر از time_slice باشد تابع intr_yield_on_return صدا زده می شود که هنگام برگشتن از interrupt،  زمانبندی انجام می شود.

>> پرسش سوم: مراحلی که برای کوتاه کردن زمان صرف‌شده در `timer interrupt handler` صرف می‌شود را نام ببرید.

> سعی شده در طراحی به گونه ای عمل شود که به timer_interrput_handler هیچ گونه محاسبه ای اضافه نشود.

### همگام‌سازی

>> پرسش چهارم: هنگامی که چند ریسه به طور همزمان `timer_sleep()` را صدا می‌زنند، چگونه از `race condition` جلوگیری می‌شود؟

>با استفاده از intr_disable() وقفه را غیر فعال و دوباره فعال می کنیم و اضافه کردن به لیست sleep_pq را در این بین انجام می دهیم

>> پرسش پنجم: هنگام صدا زدن `timer_sleep()` اگر یک وقفه ایجاد شود چگونه از `race condition` جلوگیری می‌شود؟

>بخش بحرانی کد ما که همان اضافه کردن به sleep_pq است ؛ وقفه غیر فعال است.

### منطق

>> پرسش ششم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.

>ابتدا می خواستیم یک متغیری به نام تعداد تیک های باقی مانده قرار دهیم ولی مشکل این بود که در هر timer_interrupt_handler باید کل لیست را آپدیت می کردیم اما طراحی فعلی از متغیر final_tick استفاده می کند که با استفاده از heap_queue به سادگی می توان آن را مدیریت کرد و محاسبات خارج از timer_interrupt_handler  انجام می شود. 

یک طراحی دیگر این بود که دو متغیر is_on_timer_sleep و remained_ticks را به خود struct thread اضافه کنیم که علاوه بر مشکلات طراحی قبلی سایز struct  thread  را نیز زیاد می کند که با توجه به سایز stack هر thread مطلوب نیست.

## زمان‌بند اولویت‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در ۲۵ کلمه یا کمتر توضیح بنویسید.

	 struct thread_node{
	         struct thread* the_thread;
	         int64_t effective_priority;
	         int64_t base_priority;
	         struct lock *locks_acquired_pq;
	         struct thread_node* left_child;
	         struct thread_node* right_child;
	 }
	 struct thread_node* ready_list;
	 struct semaphore
	 {
		 unsigned value;
		 struct thread_node* waiters_pq;
	 }
	 struct lock 
	 {
		 struct thread_node *holder;
		 struct semaphore semaphore;
		 struct lock *left_child;
		 struct lock *right_child;
	 }
   

>> پرسش دوم: داده‌ساختارهایی که برای اجرای `priority donation` استفاده شده‌است را توضیح دهید. (می‌توانید تصویر نیز قرار دهید)
ابتدا به کمک داده ساختار thread_node ( که در آن اولویت موثر و اولویت پایه را ذخیره می کنیم) صف اولویت ready_list را تعریف می کنیم. که در واقع max_heap_queue می باشد به کمک این صف اولویت در تابع schedule در هر بار ریسه با اولویت بیشینه را به حالت اجرا در می آوریم. داده ساختار thread_node یک لیست اولویت دار از قفل هایی که در اختیار دارد را نگه میدارد. این موضوع جهت رسیدگی به اهدا از منابع مختلف ضروری است. 
هر قفل صاحب خود را میشناسد و یک سمافور نیز دارد.
با تغییر داده ساختار semaphore به این صورت که لیست ریسه های منتظر آن را ( waiters) به یک Max_Heap_queue تبدیل می کنیم.  
( یعنی waiter_pq) تا در هنگام sema_up ریسه منتظر با اولویت موثر بیشینه آنبلاک کنیم. 

***

 هر ریسه ای که برای گرفتن یک قفل درخواست دهد، اگر نیاز بود اولویت قفل را افزایش میدهیم و همواره با افزایش اولویت قفل، ریسه صاحب آن نیز ممکن است effective priority بالاتری بگیرد.
هنگام آزاد کردن یک قفل، باید lock_priority را برابر effective priority ریسه با بیشترین اولویت در صف انتظار آن قفل قرار دهیم.
و effective_priority صاحب قفل نیز پس از آزاد کردن یک قفل، برابر effective_priority ریسه با بیشترین اولویت در صف انتظار آن قفل میشود.
 


### الگوریتم

>> پرسش سوم: چگونه مطمئن می‌شوید که ریسه با بیشترین اولویت که منتظر یک قفل، سمافور یا `condition variable` است زودتر از همه بیدار می‌شود؟
در هنگام آزادسازی یک قفل، سمافور یا condition_variable ، ریسه ای را آنبلاک کرده که در صف waiter های سمافور یا condtition_variable یا قفل دارای بیشترین اولویت موثر هست (با کمک waiters_pq) 
>> پرسش چهارم: مراحلی که هنگام صدازدن `lock_acquire()` منجر به `priority donation` می‌شوند را نام ببرید. دونیشن‌های تو در تو چگونه مدیریت می‌شوند؟ 
قبل از آنکه ریسه ی جاری برای گرفتن قفل به حالت انتظار برود ( sema_down (&lock->semaphore)) به دارنده ی فعلی قفل  (lock -> holder ) effective_priority برابر با effective_priority ریسه جاری نسبت می دهیم (فقط در جهت افزایش).


***
با توجه به این نکته که اولویت موثر ریسه جاری را اهدا کرده ایم؛ 
در نتیجه اهدا های تو در تو را نیز خواهیم داشت به این صورت که آخرین ریسه که اولویت موثر اهدا شده به خودش را دارد ابتدا بایستی تمام قفل ها و سمافور های در اختیار خودش را آزاد کرده تا ریسه هایی که به صورت تو در تو منتظر همین ریسه بودند فرآیند بالا به شکل مشابه برایشان تکرار شود.  

>> پرسش پنجم: مراحلی که هنگام صدا زدن `lock_release()` روی یک قفل که یک ریسه با اولویت بالا منتظر آن است، رخ می‌دهد را نام ببرید.
هنگام آزاد کردن یک قفل، باید effective_priority صاحب قفل تغییر کند. بدین منظور، از لیست قفل های صاحب آن میرویم و ریسه ای با بیشترین اولویت که منتظر هر کدام از قفل ها است را پیدا میکنیم. با این کار به ازای هر قفل، یک عدد اولویت خواهیم داشت. بین این اعداد بیشینه را به عنوان effective_priority صاحب قفل قرار میدهیم. اگر هم قفلی دیگر برای صاحب باقی نمانده بود، effective را برابر base_priority قرار میدهیم.

در انتهای تابع lock_release تابع sema_up فراخوانی می شود در تابع sema_up ریسه ای را آنبلاک کرده که در صف waiter های سمافور دارای بیشترین اولویت موثر هست (با کمک waiters_pq) که بدین معنی است که ریسه با اولویت بالای منتظر در صف ready_list برای schedule شدن قرار می گیرد تا سپس نوبت در اختیار قرار گرفتن قفل به او برسد.
### همگام‌سازی

>> پرسش ششم: یک شرایط احتمالی برای رخداد `race condition` در `thread_set_priority` را بیان کنید و توضیح دهید که چگونه پیاده‌سازی شما از رخداد آن جلوگیری می‌کند. آیا می‌توانید با استفاده از یک قفل از رخداد آن جلوگیری کنید؟
فرض کنیم ریسه A یک قفل را در اختیار دارد. ریسه B که اولویت بالاتری دارد میخواهد قفل را در اختیار بگیرد. در تابع lock_acquire، ممکن است هنگامی که ریسه B قصد donation دارد، موقتاً ریسه A به اولویت بالاتری از B انتقال یابد و کارهایش را انجام داده و سپس قفل ها را آزاد کند. وقتی به B برمیگردیم، این ریسه از اتفاقاتی که افتاده بی خبر است و اولویت ریسه A را بالا میبرد، در صورتی که نیازی به این کار نیست و ریسه A قفل را آزاد کرده است.
ما با غیرفعال کردن وقفه ها در lock_acquire و lock_release مانع این کار میشویم.
همچنین در thread_set_priority مادامی که میخواهیم priority ریسه فعلی را ببینیم و سپس آن را تغییر دهیم، باید وقفه ها غیرفعال باشند.

فرض کنید در تابع  thread_set_priority هستیم و قبل از نسبت دادن priority جدید ( p = 30) به ریسه مد نظر توسط ریسه دیگر تابع schedule  فراخوانی شده باشد و در آن لحظه بالاترین اولویت برای ریسه ها درون صف ready_list کمتر از مقدار مد نظر برای اختصاص در تابع thread_set_priority باشد. ( MAX p = 25)

خیر، اختصاص دادن قفل برای دسترسی به دستورات این تابع تاثیری در جلوگیری از schedule شدن ریسه ی با اولویت پایین تر از آن ( Max p = 25)  ندارد و راه حل متوقف کردن موقتی وقفه ها در این تابع می باشد. 

### منطق

>> پرسش هفتم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.



## سوالات افزون بر طراحی

>> پرسش هشتم: در کلاس سه صفت مهم ریسه‌ها که سیستم عامل هنگامی که ریسه درحال اجرا نیست را ذخیره می‌کند، بررسی کردیم:‍‍ `program counter` ، ‍‍‍`stack pointer` و `registers`. بررسی کنید که این سه کجا و چگونه در `Pintos` ذخیره می‌شوند؟ مطالعه ‍`switch.S` و تابع ‍`schedule` در فایل `thread.c` می‌تواند مفید باشد.
>ابتدا باید stack_frame تابع switch_threads را ببینیم:
>struct switch_threads_frame

  {

    uint32_t edi;               /*  0: Saved %edi. */

    uint32_t esi;               /*  4: Saved %esi. */

    uint32_t ebp;               /*  8: Saved %ebp. */

    uint32_t ebx;               /* 12: Saved %ebx. */

    void (*eip) (void);         /* 16: Return address. */

    struct thread *cur;         /* 20: switch_threads()'s CUR argument. */

    struct thread *next;        /* 24: switch_threads()'s NEXT argument. */

  };
  ابتدای تابع switch_threads مشاهده میکنیم که ۴ رجیستر اشاره شده در فریم بالا push میشوند. بنابراین چهار رجیستر بالا از پوش شدن قبلی روی استک مانده اند. همچنین هنگام فراخوانی تابع switch_threads به صورت اتوماتیک return_address را روی استک پوش شده است. بنابراین قسمت بعدی استک هم این گونه ساخته شده است. دو قسمت بعدی هم ورودی های تابع هستند که میدانیم با توجه به calling convention روی استک قرار میگیرند (از راست به چپ، با توجه به prototype تابع در switch.h)
  حال نکته در ذخیره کردن stack_pointer است. با سه دستور زیر sp برای ریسه فعلی ذخیره میشود:
  mov thread_stack_ofs, %edx
  # Save current stack pointer to old thread's stack, if any.
  movl SWITCH_CUR(%esp), %eax
  movl %esp, (%eax,%edx,1)
  دستور اول صرفاً مقدار offset مورد نیاز در struct thread برای رسیدن به المان stack را میدهد (در thread.c تعریف شده است). بنابراین رجیستر edx دارای offset لازم است). دستور بعدی مقدار stack_pointer فعلی بعلاوه ۲۰ را در eax میریزد. مقدار SWITCH_CUR برابر ۲۰ تعریف شده است و از stack_frame تابع switch_threads معلوم است که چرا این مقدار تعریف شده. حال دستور بعدی واقعاً sp را روی struct thread* cur مینویسد. در واقع دستور اسمبلی داده شده مقدار esp را در eax + edx مینویسد. از قبل میدانیم که eax به struct thread* cur اشاره میکند که به ورودی تابع داده شده است. و همچنین edx نیز offset مورد نیاز برای رسیدن به المان stack از struct thread را میدهد و بدین ترتیب sp برای ریسه فعلی ذخیره میشود.
  با روندی دقیقاً مشابه فوق ولی در جهت عکس (یعنی storeها به load تبدیل میشوند) میتون مقادیر بالا برای thread جدید را لود کرد و اجرای ترد جدید آغاز میشود.

>> پرسش نهم: وقتی یک ریسه‌ی هسته در ‍`Pintos` تابع `thread_exit` را صدا می‌زند، کجا و به چه ترتیبی صفحه شامل پشته و `TCB` یا `struct thread` آزاد می‌شود؟ چرا این حافظه را نمی‌توانیم به کمک صدازدن تابع ‍`palloc_free_page` داخل تابع ‍`thread_exit` آزاد کنیم؟
>فراخوانی thread_exit منجر به schedule میشود و در schedule هم تابع switch_threads باید صدا زده شود که ریسه جدیدی جایگزین شود. در بالا مشاهده کردیم که به struct thread* cur برای switch_threads نیاز داریم پس نمیتواند آزاد شده باشد و به خاطر همین این کار را در thread_schedule_tail انجام میدهیم (توسط ریسه جدید). به این صورت انجام میشود که اگر status ریسه قبلی DYING بود struct thread آن را free میکنیم. لازم است اشاره شود که مطابق توضیحات بالا، اشاره گر به ریسه فعلی (cur) در تابع switch_threads را در eax قرار داده بودیم و این همان رجیستری است که مقادیر برگشتی توابع را در خود دارد، پس در واقع تابع switch_threads اشاره گر به ساختار ریسه قبلی را بر میگرداند و در thread_schedule_tail استفاده میشود.

>> پرسش دهم: زمانی که تابع ‍`thread_tick` توسط `timer interrupt handler` صدا زده می‌شود، در کدام پشته اجرا می‌شود؟

>> پرسش یازدهم: یک پیاده‌سازی کاملا کاربردی و درست این پروژه را در نظر بگیرید که فقط یک مشکل درون تابع ‍`sema_up()` دارد. با توجه به نیازمندی‌های پروژه سمافورها(و سایر متغیرهای به‌هنگام‌سازی) باید ریسه‌های با اولویت بالاتر را بر ریسه‌های با اولویت پایین‌تر ترجیح دهند. با این حال پیاده‌سازی ریسه‌های با اولویت بالاتر را براساس اولویت مبنا `Base Priority` به جای اولویت موثر ‍`Effective Priority` انتخاب می‌کند. اساسا اهدای اولویت زمانی که سمافور تصمیم می‌گیرد که کدام ریسه رفع مسدودیت شود، تاثیر داده نمی‌شود. تستی طراحی کنید که وجود این باگ را اثبات کند. تست‌های `Pintos` شامل کد معمولی در سطح هسته (مانند متغیرها، فراخوانی توابع، جملات شرطی و ...) هستند و می‌توانند متن چاپ کنند و می‌توانیم متن چاپ شده را با خروجی مورد انتظار مقایسه کنیم و اگر متفاوت بودند، وجود مشکل در پیاده‌سازی اثبات می‌شود. شما باید توضیحی درباره این که تست چگونه کار می‌کند، خروجی مورد انتظار و خروجی واقعی آن فراهم کنید.
>اساساً باید به نوعی روی پدیده priority inversion متمرکز شویم. بدین منظور، تست مورد نظر ابتدا یک ریسه A با اولویت 1 را ایجاد میکند (فرض میشود عدد بالاتر نشان دهنده اولویت بیشتر باشد). سپس این ریسه A ابتدا منبع S1 را قفل میکند و سپس ریسه B با اولویت 2 را ایجاد میکند. طبیعتاً در این حالت باید ریسه B در حالت اجرا قرار گیرد. سپس ریسه B ابتدا ریسه C با اولویت 3 را ایجاد میکند و با این کار اجرا به ریسه C منتقل میشود. ریسه C برای قفل منبع S1 درخواست میدهد و priority donation انجام میگیرد و اکنون effective priority ریسه A برابر 3 است. ولی از آنجا که پیاده سازی مشکل دارد، به جای ریسه A به صورت اشتباه ریسه B را اجرا میکند. اکنون با printf در مکان های مناسب میتوان این موضوع را نشان داد که ابتدا B اجرا میشود در صورتی که نباید این گونه باشد. سه شبه کد زیر را برای سه thread گفته شده در نظر میگیریم:

	thread_A () {
	lock (S1);
	thread_create (B, priority=2);
	thread_yield (); // Force scheduling of thread B
	printf("A is running\n");
	unlock(S1);
	}
	
	thread_B () {
	thread_create (C, priority=3);
	thread_yield (); // Force scheduling of thread C
	printf ("B is running\n");
	}
	
	thread_C () {
	lock (S1);
	unlock (S1);
	}
خروجی مورد نظر این است که ابتدا A is running جاپ شود و سپس B is running اما در عمل به دلیل مشکلی که وجود دارد عکس این عمل اتفاق می افتد. با توجه به ترتیب کدهای نوشته شده، race condition هم وجود ندارد و همواره این اتفاق تکرار خواهد شد.


## سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد. نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست. ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>> به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>> آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>> آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>> آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>> آیا حرف دیگری دارید؟
