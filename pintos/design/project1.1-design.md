# تمرین گروهی ۱.۱ - مستند طراحی

گروه 3

-----

 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 

مقدمات

----------

> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

+ https://stackoverflow.com/questions/22210546/whats-the-difference-between-strtok-and-strtok-r-in-c

+ https://www.quora.com/What-is-the-advantage-of-having-the-shell-parse-commands-i-e-into-an-executable-name-and-arguments-rather-than-having-the-kernel-do-it

+ https://cseweb.ucsd.edu/classes/sp16/cse120-a/applications/ln/lecture15.html

+ 

پاس‌دادن آرگومان

============

داده‌ساختار‌ها

----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.
در این قسمت هیچ داده ساختار یا typedef یا enum استفاده نشد.

الگوریتم‌ها

------------

> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟
طبیعتاً آرگومانها را باید وقتی روی استک قرار دهیم که استک برنامه درست شده باشد. میدانیم استک در تابع load با فراخوانی setup_stack درست میشود. بنابراین به طور بالقوه سه جا برای تنظیم استک برنامه میشناسیم: داخل تابع setup_stack، داخل تابع load (پس از فراخوانی setup_stack) و داخل تابع start_process (بعد از فراخوانی load)
ما تصمیم گرفتیم داخل تابع setup_stack این کار را انجام دهیم. چرا که داخل این تابع کار install_page را انجام میدهیم. قبل از تخصیص دادن صفحه استک، میتوان با یک محاسبات روی کل رشته ورودی مشخص کرد که چقدر استک مورد نیاز است و در صورت نیاز بیش از 1 صفحه در نظر گرفت. 
با توجه به صفحه 19 از سند pintos، ابتدا باید خود رشته ها را در بالاترین مکان استک قرار داد و سپس با توجه به argc معلوم است که چند اشاره گر باید روی استک قرار داده شود (به اندازه argc+2 اشاره گر نیاز داریم روی استک قرار دهیم). با توجه به این موضوع، پس از قرار دادن خود رشته ها روی استک و قبل از پوش کردن اشاره گرها، میتوان محاسبه کرد که پس از پوش کردن اشاره گرها آیا esp به صورت 16-byte aligned خواهد بود یا خیر. در صورت alignنبودن باید مقدار مناسبی را از esp کم کنیم. در نهایت هم یک آدرس return روی استک میگذاریم (این آدرس در واقع fake return address است چون هیچوقت قرار نیست برگردیم ولی برای رعایت calling convention باید قرار دهیم)
همانطور که در بالا اشاره شد، با یک محاسبات ساده میتوانیم متوجه شویم چند صفحه برای استک نیاز داریم که آنها را قرار دهیم.

منطق طراحی

-----------------

> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

تابع strtok_r توانایی فراخوانی از چندین ریسه را دارد چون حالت خود را در متغیر global نگه نمی دارد و معمولا یک آرگومان اضافی میگیرند که حالت بین فراخوانی های متفاوت را در آن آرگومان ذخیره کنند. ( پسوند _r معادل reentrant است)

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

در این صورت کرنلی که پیاده سازی می کنیم برای شل های متعدد قابلیت اجرا به صورت مستقل را دارا بوده و مدیریت و تامین امنیت کرنل نیز ساده تر خواهد بود 

فراخوانی‌های سیستمی

================

داده‌ساختار‌ها

----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

	typedef struct child {
	pid_t pid; // process id of the child
	struct child *children; // children of this process
	struct semaphore *loading_sem; // exec will wait until child is loaded
	bool load_status; // if false, should release all the resources
	} child_t;
	
	struct thread {    /* Owned by thread.c. */
		tid_t tid;                          /* Thread identifier. */
		enum thread_status status;          /* Thread state. */    
		char name[16];                      /* Name (for debugging purposes). */    uint8_t *stack;                     /* Saved stack pointer. */
		int priority;                       /* Priority. */
		struct list_elem allelem;           /* List element for all threads list. */
		    /* Shared between thread.c and synch.c. */
	   struct list_elem elem;              /* List element. */
	   #ifdef USERPROG
	   /* Owned by userprog/process.c. */
		struct semaphore wait_sem;         /* used in wait syscall */
		struct semaphore loading_sem;      /* exec waits until fully loaded */
	   struct list open_files;            /* list of open files for this thread */
	   struct list children;              /* children of this thread */
	   struct list_elem child_elem;       /* child element */
	   struct thread *parent;             /* parent of this process */
	   bool load_status;                  /* if false, file failed to load */
	   uint32_t *pagedir;                 /* Page directory. */
	   #endif
	       /* Owned by thread.c. */
	   unsigned magic;                     /* Detects stack overflow. */  
	};	
	typedef struct PCB {
	struct file *p_files[128];
	} 

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

زمانی که یک فایل توسط یک پردازه باز می شود یک عضو در open file table (که در کل سیستم مشترک است) ایجاد شده و یک اشاره گر به آن عضو داخل file descriptor table (که مختص هر پردازه است) مربوط به پردازه ایجاد می شود. file descriptor یک عدد صحیح بوده که بعنوان اندیس file descriptor table استفاده می شود. بنابراین در کل سیستم این fd ها میتوانند یکتا نباشند

الگوریتم‌ها

------------

> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.
ما از روش validity check استفاده میکنیم و برای این کار که بسیار در syscallهای مختلف تکرار میشود یک تابع is_valid_ptr را ارائه کرده ایم که شروط سه گانه ای که در بخش ۴.۲.۴ سند pintos موجود است را چک میکند و نتیجه را به صورت یک bool بر میگرداند. سپس دو حالت داریم. یا اشاره گر کاربر به یک فایل است که در این صورت با استفاده از syscallهای write و read که در داخل آنها نیز از توابع filesystem استفاده شده است خواندن و نوشتن را انجام میدهیم. با استفاده از توابع read و write این عمل امکان پذیر است. هر دو تابع در آرگومان های خود توصیف کننده فایل ، اندازه بافر و اشاره گری به آن می گیرند و پس از بررسی معتبر بودن و مجاز بودن دسترسی به حافظه و همچنین معتبر بودن عملیات از سوی کاربر به انجام آن از طریق توابع موجود در filesys پرداخته می شود و همچنین برای ورودی و خروجی استاندارد از توابع putbuf و inputgetc استفاده می کنیم.
اگر اشاره گر کاربر به حافظه کاربر باشد، عملا پس از validity_check میتوانیم اشاره گر را dereference کنیم.



> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

اگر فرض کنیم ۴۰۹۶ بایت متوالی داریم (یعنی آدرس مجازی آنها پشت هم است)، آنگاه این بایت ها حداکثر در دو صفحه قرار میگیرند و حداقل در یک صفحه. به تعداد صفحات باید تابع get_page صدا زده شود که بررسی انجام شود.
در حالتی که فقط ۲ بایت را بخواهیم بخوانیم هم ممکن است این ۲ بایت در دو صفحه (بایت اول پایان صفحه n و بایت دوم شروع صفحه n+1) یا یک صفحه قرار گرفته باشند. باز هم باید به تعداد صفحات تابع مورد نظر صدا زده شود.

اما اگر این بایتها به صورت متوالی نباشند (آدرس مجازی شان متوالی نباشد) برای حالت اول، حداکثر به ۴۰۹۶ بار فراخوانی تابع get_page نیاز داریم (هر فراخوانی برای یک بایت) و حداقل نیز این است که همه در یک صفحه قرار گرفته باشند و با یک فراخوانی کار انجام شود.
برای حالت دو بایت غیرمتوالی نیز حداکثر ۲ و حداقل ۱ فراخوانی نیاز داریم.

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.
پس از فراخوانی wait syscall تابع process_wait را با ورودی tid فرزند اجرا میکنیم. ریسه در حال اجرا (curent_thread) را گرفته و در لیست ریسه های فرزند آن به دنبال tid ورودی تابع میگردیم. در صورت آن که ریسه فرزند مورد نظر پیدا شد wait_sem مربوط به current_thread را down میکنیم.
پس از اجرای کامل ریسه فرزند و اتمام آن، تابع process_exit فراخوانی شده و دوباره current_thread گرفته میشود. اگر این current_thread ریسه فرزند بود (parent آن NULL نباشد) پردازه current_thread را از لیست فرزندان parent خودش حذف میکنیم. و wait_sem ریسه parent را up میکنیم.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

با تعریف تابعی به اسم  is_valid_ptr با بررسی سه شرط اصلی که در بخش ۴.۲.۴ منبع pintos  ضمیمه شده در تمرین GHW0 تعریف شده اند ُ تعریف کردن این تابع باعث میشود که رسیدگی به خطا به صورت تمیز تری مدیریت شود، چون مدیریت خطا به این نحو بین تمامی syscall ها مشترک است.
در صورتی که آرگومان های کاربر معتبر باشند، syscall کار خودش را انجام میدهد و منبع خاصی گرفته نمیشود. ولی اگر معتبر نباشد، باید پردازه را خاتمه دهیم و بدین ترتیب باید پیاده سازی exit syscall (یا process_exit) به گونه ای باشد که تمام منابع تحت اختیار یک پردازه را آزاد کند، در این صورت میتوان تضمین کرد که منابع حتما آزاد میشوند.

همگام‌سازی

---------------

> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

بعد از اجرای دستور با کمک تابع process_execute یک sema_down می گذاریم تا منتظر بارگذاری کامل فایل اجرایی بماند سپس در تابع start_process در کد process.c بعد از پایان بارگذاری فایل اجرایی ( تابع load) sema_up را اجرا می کنیم تا ترد از حالت انتظار بخش قبل خارج شود و سپس چک می کنیم که خروجی تابع load آیا successful بوده یا خیر و بر این اساس یک فلگ را برای ترد فرزند ست می کنیم که نمایان گر بارگزاری موفق یا ناموفق آن ریسه است که در نهایت با توجه به این فلگ خروجی -1 یا tid را در فراخوانی سیستمی exec بر میگردانیم (به طور پیش فرض مقدار برگشتی یک syscall داخل ثبات eax قرار میگیرد)

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟
اگر C قبل از wait(C) خارج شده باشد در واقع یک بار sema_up(wait_sem) انجام شده که این wait_sem مربوط به parent است. به عنوان مثال مقدار wait_sem برابر ۱ شده است. حال وقتی ریسه parent وارد تابع process_wait میشود، وقتی به کد sema_down(wait_sem) که این wait_sem مربوط به خودش است میرسد، دیگر صبر نمیکند و از آن عبور میکند (چون مقدار سمافور برابر ۱ است)
اگر بعد از اجرا شدن wait(C) ریسه فرزند خارج شود تا قبل از آن parent سر خط sema_down(wait_sem) منتظر مانده است (چون مقدار اولیه آن صفر است) حال که فرزند خارج شد با فراخوانی sema_up روی wait_sem پدر ریسه parent آزاد میشود.
در تمام حالات شرح داده شده فوق، پردازه فرزند به تابع process_exit میرسد. پس کافی است در تابع process_exit تمام منابع یک ریسه را آزاد کنیم در این صورت میتوان اطمینان حاصل کرد که هنگام خروج هر ریسه و از جمله ریسه فرزند C تمام منابع آن به سیستم بازگردانده میشود.
اگر P بدون منتظر ماندن خارج شود برای خودش مشکلی پیش نمیاید. همچنین برای اینکه فرزند اشتباهی sema_up را روی سمافور parent (که اکنون دیگر وجود ندارد) را صدا بزند، در یک if چک میکنیم که parent آن NULL نباشد (این حالت وقتی پیش میاید که parent قبل از فرزند خارج شود، که در این صورت باید parent فرزندانش را به NULL تنظیم کند). اگر هم parent بعد از فرزند بدون منتظر ماندن خارج شود از قبل فرزند آن sema_up را صدا زده و مقدار ۱ دارد و هیچ تاثیری روی parent نخواهد گذاشت.
منطق طراحی

-----------------

> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

یک روش دیگری که به جای validity check در سند pintos گفته شده است این است که فقط چک کنیم که اشاره گر به حافظه هسته اشاره نکند و سپس آن را dereference کنیم. در صورتی که اشاره گر NULL باشد یا به صفحه ای اشاره کند که map نشده است، به page_fault منجر شده و باید در فایل exception.c کار مدیریت خطا انجام شود. چون ممکن است هزینه اجرا شدن page_fault_handler زیاد باشد، ما تلاش کردیم همان اول معتبربودن اشاره گر را چک کنیم و سپس مقدار آن را تغییر دهیم.






> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟
یک ساختار در نظر میگیریم که حاوی یک file descriptor و یک struct file* است. سپس هر پردازه یک لیست پیوندی از این نوع ساختار را نگه میدارد که به تمام فایل های باز شده توسط آن پردازه اشاره میکنند.
این رویکرد نقطه مثبتی که دارد این است که میتوان تعداد بیشماری فایل توسط هر پردازه باز کرد. اما بدی آن این است که هر دفعه برای پیدا کردن یک فایل خاص از روی descriptor یا struct file* آن فایل، باید یک لیست را پیمایش کنیم که از (L)O که در آن L طول لیست است طول میکشد.
در مقابل، میتوانستیم یک آرایه از struct file*ها در نظر بگیریم که اندیس هر فایل با file descriptor آن مشخص شود. اگر این طراحی را در نظر میگرفتیم، باید یک محدودیت روی تعداد فایلها میگذاشتیم اما زمان look up یک فایل از روی file descriptor آن بسیار کم میشد (1)O

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟
فعلاً از همان نگاشت پیش فرض 1-1 استفاده میکنیم. سادگی این رویکرد از مزایای آن است و همچنین برای به دست آوردن پردازه معادل هر ریسه نیاز به کار خاصی نداریم و سریع میتوان pid متناظر tid و بالعکس را به دست آورد.
سوالات افزون بر طراحی

===========

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.
این تست در فایل child_bad.c قرار دارد که ابتدا stack_pointer را به یک مقدار غیرمعتبر (movl $0x20101234, %esp) تنظیم میکند و سپس یک syscall را صدا میزند. برنامه باید با exit_code=-1 خاتمه یابد.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.
در فایل sc-boundary.c این تست انجام میشود. ابتدا ناحیه مرز صفحه توسط تابع get_boundary_area() گرفته میشود و سپس یک واحد از آن کم میکند. پس در حالت فعلی یک آرگومان میتوان در آن قرار داد. اما تست مذکور دو ارگومان در آن قرار میدهد پس آرگومان دوم در ناحیه غیرمجاز قرار میگیرد.

> یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

سوالات نظرخواهی

==============

پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.
