# تمرین گروهی ۱.۱ - مستند طراحی

گروه 3

-----

 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علی جعفری <alijafari13791397@gmail.com>

امید رستم آبادی <omidrostamabadi@gmail.com> 

سینا مظاهری <sinamazaheri1707@gmail.com> 

پیمان حاجی محمد <peyman.eb15@gmail.com> 

مقدمات

----------

> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

+ https://stackoverflow.com/questions/22210546/whats-the-difference-between-strtok-and-strtok-r-in-c

+ https://www.quora.com/What-is-the-advantage-of-having-the-shell-parse-commands-i-e-into-an-executable-name-and-arguments-rather-than-having-the-kernel-do-it

+ https://cseweb.ucsd.edu/classes/sp16/cse120-a/applications/ln/lecture15.html

+ 

پاس‌دادن آرگومان

============

داده‌ساختار‌ها

----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

الگوریتم‌ها

------------

> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

منطق طراحی

-----------------

> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

تابع strtok_r توانایی فراخوانی از چندین ریسه را دارد چون حالت خود را در متغیر global نگه نمی دارد و معمولا یک آرگومان اضافی میگیرند که حالت بین فراخوانی های متفاوت را در آن آرگومان ذخیره کنند. ( پسوند _r معادل reentrant است)

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

در این صورت کرنلی که پیاده سازی می کنیم برای شل های متعدد قابلیت اجرا به صورت مستقل را دارا بوده و مدیریت و تامین امنیت کرنل نیز ساده تر خواهد بود 

فراخوانی‌های سیستمی

================

داده‌ساختار‌ها

----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

زمانی که یک فایل توسط یک پردازه باز می شود یک عضو در open file table (که در کل سیستم مشترک است) ایجاد شده و یک اشاره گر به آن عضو داخل file descriptor table (که مختص هر پردازه است) مربوط به پردازه ایجاد می شود. file descriptor یک عدد صحیح بوده که بعنوان اندیس file descriptor table استفاده می شود. بنابراین در کل سیستم این fd ها میتوانند یکتا نباشند

الگوریتم‌ها

------------

> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

با استفاده از توابع read و write این عمل امکان پذیر است. هر دو تابع در آرگومان های خود توصیف کننده فایل ، اندازه بافر و اشاره گری به آن می گیرند و پس از بررسی معتبر بودن و مجاز بودن دسترسی به حافظه و همچنین معتبر بودن عملیات از سوی کاربر به انجام آن از طریق توابع موجود در filesys پرداخته می شود و همچنین برای ورودی و خروجی استاندارد از توابع putbuf و inputgetc استفاده می کنیم.



> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

هر دو دسترسی مورد نیاز به حافظه ممکن است در یک یا دوصفحه قرار داشته باشند .

بهترین حالت این است که هر دو در یک صفحه قرار گرفته باشند .

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

با تعریف تابعی به اسم  is_valid_ptr با بررسی سه شرط اصلی که در بخش ۴.۲.۴ منبع pintos  ضمیمه شده در تمرین GHW0  

تعریف شده اند ُ تعریف کردن این تابع باعث میشود که رسیدگی به خطا به صورت تمیز تری مدیریت شود.

چون مدیریت خطا به این نحو بین تمامی syscall ها مشترک است . 

همگام‌سازی

---------------

> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

بعد از اجرای دستور با کمک تابع process_execute یک sema_down می گذاریم تا منتظر بارگذاری کامل فایل اجرایی بماند سپس در تابع start_process در کد process.c بعد از پایان بارگذاری فایل اجرایی ( تابع load) sema_up را اجرا می کنیم تا ترد از حالت انتظار بخش قبل خارج شود و سپس چک می کنیم که خروجی تابع load آیا successful بوده یا خیر و بر این اساس یک فلگ را برای ترد فرزند ست می کنیم که نمایان گر بارگزاری موفق یا ناموفق آن ریسه است که در نهایت با توجه به این فلگ خروجی -1 یا tid را در فراخوانی سیستمی exec بر میگردانیم (به طور پیش فرض مقدار برگشتی یک syscall داخل ثبات eax قرار میگیرد)

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

منطق طراحی

-----------------

> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

ما دسترسی ایمن را برای کاربر بدین شکل پیاده سازی کردیم زیرا این روش سریع است که یک اشاره گر غیر معتبر را توسط خطای صفحه اعلان کنیم تا آن را بررسی کنیم که NULL باشد. چرا که این عمل از MMU استفاده می کند. اگر چه وقفه مربوط به خطای صفحه زمان گیر است اما در کل کارایی را بهتر می کند.






> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

سوالات افزون بر طراحی

===========

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

سوالات نظرخواهی

==============

پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.