تمرین گروهی ۳ - مستند طراحی

======================

گروه
3
-----

علی جعفری [alijafari13791397@gmail.com]

امید رستم آبادی [omidrostamabadi@gmail.com]

سینا مظاهری [sinamazaheri1707@gmail.com]

پیمان حاجی محمد [peyman.eb15@gmail.com]

مقدمات

----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش

============

داده‌ساختار‌ها و توابع

---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

    static struct lock cache_lock; /* Avoid race condition while modifying cache enteries meta-data */
    
    struct cache_entry
    {
	    struct inode *its_inode; /* Which file does it belong? */
	    int used; /* Set when using this block, clear when clock hand  passes by */
	    int dirty; /* The version in memory is different from disk */
	    block_sector_t sector; /* Number of the sector has been cached */
	    char in_mem_data[BLOCK_SECTOR_SIZE]; /* Actual data */
    };
    
    /* If a sector is being used (or migrated to/from disk) by a process, prevent other processes from accessing that entry */
    struct list busy_sectors;
    
    struct busy_sector
    {
    struct inode *its_file;
    block_sector_t sector; /* Sector number */
    struct lock *busy_lock; /* Used for synchronization. Other threads wait on this lock when they find the sector busy */
    struct list_elem busy_elem; /* Put elements in busy_sectors list */
    }
    
    struct file
    {
    struct inode *inode; /* File's inode */
    off_t pos; /* Current position */
    bool deny_write; /* Has file_deny_write() been called? */
    struct lock *extension_lock; /* One process at a time can extend the file, others will wait until current extension finishes */
    }

الگوریتم‌ها

------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟
ما در طراحی خود از الگوریتم ساعت با یک شانس استفاده می کنیم. همچنین ما به بلاکهای کثیف (dirty bit set) دو شانس میدهیم و دفعه اول آنها را روی دیسک مینویسیم و دفعه بعد پاک میکنیم.

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.
هنگامی که پردازه ای برای بلاک N-ام درخواست میدهد، اگر بلاک در cache نباشد، پردازه تا آمدن داده مسدود میشود. هنگامی که بلاک N-ام به حافظه cache منتقل شد داده در اختیار پردازه قرار گرفته و به کارش ادامه میدهد. در این بین، بدون اینکه پردازه درخواست کننده بلاک N-ام متوجه شود، یک ترد جدید درست میکنیم که بلاک N+1-ام را درخواست میکند. در این صورت اگر این بلاک در cache نباشد از دیسک به cache منتقل میشود. ایجاد یک ترد جدید به این دلیل ضروری است که فرآیند انتقال بلاک N+1-ام باید نسبت به پردازه درخواست کننده به صورت آسنکرون انجام شود.
یک استراتژی ممکن برای پیاده سازی **write-behind** نیز این است که از تایمر توسعه داده شده در فاز قبلی (یا یک تایمر ساده تر) استفاده کنیم و یک thread مختص این کار داشته باشیم که هر چند ثانیه یک بار فعال شده و چند بلاک کثیف را روی دیسک مینویسد.

همگام سازی

-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟
با توجه به الگوریتم پیاده‌سازی‌شده برای جایگزینی بلاک‌های بافرکش، اگر یک بلاک مرتباً مورد استفاده قرار گیرد، بیت used آن 1 می‌شود و وقتی عقربه ساعت از آن می‌گذرد آن را حذف نخواهد کرد.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟
یک لیست به نام busy_sectors تعبیه شده است که هنگامی که یک پردازه در حال خواندن/نوشتن/جا‌به‌جایی یک sector است از دسترسی سایر پردازه‌ها به آن sector جلوگیری شده و در لیست waiterهای lock مورد نظر اضافه می‌شوند که پس از اتمام کار پردازه فعلی کار خود را ادامه دهند.

منطق طراحی

-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

+ بافرکش: مثلاً دو پردازه از طریق یک فایل اطلاعاتی را به اشتراک گذاشته اند. یک پردازه مرتباً اطلاعات ثابتی (مثلاً 200 بایت اطلاعات) را در فایل می‌نویسد و پردازه دیگر آن‌ها را می‌خواند. در این صورت سکتور مربوط به این 200 بایت همواره در cache قرار گرفته و دسترسی بسیار سریع‌تر از دیسک صورت می‌گیرد.
+ سناریو read-ahead: مثلاً یک فایل بزرگ داریم که تعداد بسیار زیادی عدد در آن نوشته شده که مربوط به اندازه‌گیری در ساعت‌ها مختلف هستند. می‌خواهیم میانگین ماهانه این کمیت را محاسبه کنیم. باید به صورت متوالی فایل را از اول تا آخر بخوانیم و پردازش را انجام دهیم. در این صورت خواندن بلاک‌های جلوتر فایل کار را سریع‌تر می‌کند چون به صورت ترتیبی از ابتدا تا انتهای فایل را دسترسی پیدا می‌کنیم.
+ سناریو write-behind: این تکنیک در crash ناگهانی سیستم که داده‌ها از حافظه پاک می‌شوند مانع از دست رفتن داده‌ها می‌شود. مثلاً اگر سیستمی داریم و تعداد قابل توجهی write انجام داده‌ایم در این صورت تعداد زیادی از بلاک‌های موجود در cache کثیف هستند و اگر در این شرایط سیستم به هر دلیلی fail کند داده‌ها زیادی از دست می‌رود. ولی با وجود write-behind هر چند ثانیه یک بار داده‌ها به دیسک منتقل می‌شوند و durable هستند.

فایل‌های قابل گسترش

=====================

داده‌ساختار‌ها و توابع

---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

	struct inode_disk {
		block_sector_t start;
		off_t length;
		unsigned magic;
		uint32_t direct_ptr[123];
		uint32_t indirect_ptr;
		uint32_t dbl_indirect_ptr;
	}
	static uint32_t GROUP_SIZE = 50;
	static uint32_t GROUP_COUNT = 10;
	static struct bitmap[GROUP_COUNT];

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟ بیشترین سایز بدین شکل قابل محاسبه خواهد بود:
512*(128+128+123 * 128) = 8517120 > 23^2

همگام سازی

----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.
در هنگام گسترش یک فایل، قفلی را که برای آن فایل تعریف شده است را (extention_lock) گرفته و تا زمانی که عملیات گسترش توسط ریسه جاری به صورت کامل انجام نشده است آن قفل را آزاد نمی کنیم تا دیگر ریسه ها که میخواهند همین فایل را گسترش دهند در هنگام lock_aquire به حالت انتظار روند تا کار گسترش توسط ریسه دارای قفل ذکر شده به پایان برسد

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.
در هنگام گسترش فایل توسط ریسه B، زمانی مقدار len و اشاره گر به انتهای فایل را آپدیت می کنیم که عملیات گسترش توسط ریسه B به صورت کامل انجام شده باشد؛ بدین صورت در هنگام خواندن ریسه A از روی آن فایل، اگر زودتر از تمام شدن کار ریسه B اقدام به خواندن بکند، از دید ریسه A در حال خواندن فایلی با اندازه len قدیمی است و در واقع هیچ یک از داده های جدید نوشته شده توسط B را نخواهد خواند و در صورتی که بعد از اتمام کار B شروع به خواندن بکند len مقدار جدید به خود گرفته و تمامی داده های جدید نوشته شده B را خواهد خواند و در این بین داده ای نامرتبط و غیر معتبر نیز خوانده نخواهد شد

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.
پس از خواندن یا نوشتن کامل تعداد مشخصی sector در مرحله scheduling، قفل مربوط به آن sector های نوشته/خوانده شده را آزاد می کنیم تا پس از scheduling قفل ذکر شده به دست ریسه های خواننده یا نویسنده منتظر اتمام کار با آن سکتور ها برسد و عدالت در امر خواندن و نوشتن رعایت شود

منطق طراحی

----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.
 بله، زیرا فایل های با اندازه کوچک بدون indirection، فایل های متوسط با یک مرحله، و فایل های بزرگ تر با دو مرحله indirection می توانند در دیسک ذخیره شوند. دلیل اینکه تنها دو اشاره گر از 125 تا را به اشاره گر های غیر مستقیم تخصیص داده ایم این است که میخواهیم تا حداکثر سایز ممکن را بدون indirection مدیریت کنیم. (فایل های تا حداکثر 63 کیلوبایت را مدیریت کنیم). اولویت با وجود کمترین اشاره گر های با تعداد بالای سطح در direction است بنابراین تا حد امکان از تعداد double indirection ها کم می کنیم تا به این نتیجه می رسیم که وجود یک dbl indirect pointer برای ذخیره سازی فایل با اندازه 8MiB الزامی می باشد. 

زیرمسیرها

============

داده‌ساختار‌ها و توابع

---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

	struct dir_entry
	{
	block_sector_t inode_sector;
	char name[NAME_MAX + 1];
	bool in_use;
	bool is_dir; /* If it's a directory entry */
	};
	
	struct dir
	{
	struct inode *inode;
	off_t pos;
	struct lock *dir_lock;
	}

الگوریتم‌ها

-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟
ابتدا هر دو فرمت را به absolute استاندارد تبدیل کرده (یعنی مثلاً چند / را به یک / تبدیل می کنیم). سپس این مسیر استاندارد parse کرده و به ترتیب از root در دایرکتوریهای مختلف داخل میشویم تا به فایل یا دایرکتوری مورد نظر برسیم.
در هر دایرکتوری همواره دو dir_entry با نامهای خاص . و .. ایجاد میکنیم که به ترتیب به دایرکتوری فعلی و پدر آن اشاره میکنند.
همگام سازی

-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟
هر struct dir یک قفل دارد که هر کسی بخواهد هر عملیاتی روی آن dir انجام دهد باید آن lock را acquire کند. بدین وسیله اطمینان حاصل میشود که state هر دایرکتوری همواره معنی دار خواهد ماند. اگر دو درخواست حذف وجود داشته باشد تنها یکی از آنها قفل را میگیرد و حذف انجام میشود و دیگری به ارور non-existing dir/file بر خواهد خورد. ما اجازه حذف مسیری که CWD یک ریسه دیگر باشد را اجازه میدهیم اما تنها لینکهای آن را پاک میکنیم و inode آن از سیستم حذف نمیشود چون reference count آن همچنان بزرگتر از ۱ خواهد ماند و تنها وقتی inode به صورت کامل حذف میشود که تمام reference های آن پاک شوند. بنابراین عملیاتهای بعدی روی آن دایرکتوری قابل انجام نیستند (یعنی از مسیر پدر به آن دایرکتوری دیگر لینکی وجود ندارد و در صورتی که کسی بخواهد آن را پیدا کند نمیتواند این کار را بکند).

منطق طراحی

-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟
اگر میخواستیم اجازه ندهیم باید یک فلگ یا قفل اضافه تعریف میکردیم که حجم struct dir یا dir_entry را افزایش میداد ولی با این کار عملاً از پیچیدگی بیهوده سیستم عامل جلوگیری کردیم.

### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟
